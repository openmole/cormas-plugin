# OpenMOLE - Cormas plugin

## Cormas presentation

Cormas is an Agents Based Simulation platform, Focus on models for natural renewable resource management. Cormas, is oriented towards the representation of interactions and point of view between stakeholders about the use of natural renewable resources.

Cormas is a simulation platform based developed in SmallTalk on the pharo programming environment. Using power of Smalltalk and a pur free software philosophical approach under pharo Cormas allows the development of applications in object-oriented programming approach. Cormas pre-defined entities are SmallTalk generic classes from which, by specialization and refining, users can create specific entities for their own model.

## How To install it ?

Plugin compilation is automatically generated by Jenkins. You can download the pre-build plugin [here](https://jenkins.iscpif.fr/job/cormas-plugin-8dev/). Once you have run the service, you can load the `cormas-task_XX.jar` as plugin.

## How it work

OpenMole will interact with Pharo/Cormas using JSON formalism. Using OpenMole, you will generate from the task or from sampling methods as many files as need.
Each JSON files will be sent within a docker container with Pharo/Cormas. Each instance of this container will run a model and openMole will wait for results.

Those results will be formed in JSON and send back from the docker file to OpenMole where data will be serialized and instanced as an aggregation of openMole variable.  

## How to use it ?
Once you have loads `cormas-task_XX.jar` you will be able to interact with pharo/cormas using the common way of thinking in OpenMole.

How does it work ? Take a look at those exemple !

### Basic CORMASTask in a workflow

Basically you can prepare a script as :

```scala
// OpenMole Variable definition.
// Those variables will be populated in openMole
// and send in JSON to Pharo/Cormas
val numberOfFires = Val[Int]
val numberOfFiremen = Val[Int]
val percentageOfTrees = Val[Double]
val dimensionMin = Val[Int]
val dimensionMax = Val[Int]
val nbTrees = Val[Int]

// The CORMASTask take in parameters the class and method able to
// launch our simulation. In OUr case using the Cormas-Model-FireAutomata
// we run a methods build for OpenMole. You can take a look.
// set() allow you to pass some other thing to your task. You can pass :
// * your model as a file.st
// * inputs from OpenMole Variable
// * outputs as an array
// * defined parameters how doesn't change between simulation.

val model = CORMASTask("CMFireAutomataModel simuOpenMole") set (
  //resources += workDirectory / "Cormas-Model-FireAutomata.st",
  cormasInputs += numberOfFires,
  cormasInputs += numberOfFiremen,
  cormasInputs += percentageOfTrees,
  cormasInputs += dimensionMin,
  cormasInputs += dimensionMax,
  cormasOutputs += nbTrees,

  outputs += (numberOfFires, numberOfFiremen, percentageOfTrees, dimensionMin, dimensionMax),

  numberOfFires := 3,
  numberOfFiremen := 10,
  percentageOfTrees := 0.65,
  dimensionMin := 60,
  dimensionMax := 80
)

// With the DirectSampling() method you define an easy wait to generate
// a sampling for numberOfFires between 1 to 10.
DirectSampling(
  evaluation = model hook CSVHook(workDirectory / "results.csv"),
  sampling = numberOfFires in (1 to 10)
)

```

### Use result as input for another task

This example is quite the same as before. The only difference is in the `DirectSampling()` methods in which we plug results in a calculation task in order to have the median when all run is turned back.

```scala
val numberOfFires = Val[Int]
val numberOfFiremen = Val[Int]
val percentageOfTrees = Val[Double]
val dimensionMin = Val[Int]
val dimensionMax = Val[Int]
val nbTrees = Val[Int]

val model = CORMASTask("CMFireAutomataModel simuOpenMole") set (
  //resources += workDirectory / "Cormas-Model-FireAutomata.st",
  cormasInputs += numberOfFires,
  cormasInputs += numberOfFiremen,
  cormasInputs += percentageOfTrees,
  cormasInputs += dimensionMin,
  cormasInputs += dimensionMax,
  cormasOutputs += nbTrees,

  numberOfFires := 3,
  numberOfFiremen := 10,
  percentageOfTrees := 0.65,
  dimensionMin := 60,
  dimensionMax := 80
)

val nbTreesMedian = Val[Double]

val median =
  ScalaTask("val nbTreesMedian = nbTrees.map(_.toDouble).median") set (
    inputs += nbTrees.array,
    outputs += nbTreesMedian
  )

DirectSampling(
  evaluation = model,
  sampling = numberOfFires in (1 to 10),
  aggregation = median hook ToStringHook()
)

```
